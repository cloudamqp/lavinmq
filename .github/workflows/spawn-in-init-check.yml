name: Spawn-in-init check
on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'shard.*'
  pull_request:
    paths:
      - 'src/**'
      - 'shard.*'
      - '.github/workflows/spawn-in-init-check.yml'

jobs:
  # On main: generate and cache baseline for future PR comparisons
  baseline:
    name: Update baseline
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    container: 84codes/crystal:latest-ubuntu-24.04
    steps:
      - name: Install dependencies
        run: DEBIAN_FRONTEND=noninteractive apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y liblz4-dev nodejs llvm-dev g++ libgc-dev

      - name: Checkout
        uses: actions/checkout@v6

      - name: Shards install
        run: shards install --production

      - name: Cache checker binary
        id: cache-checker
        uses: actions/cache@v4
        with:
          path: bin/spawn-in-init-checker
          key: spawn-in-init-checker-${{ hashFiles('src/spawn_in_init_checker.cr') }}-${{ runner.os }}

      - name: Build checker
        if: steps.cache-checker.outputs.cache-hit != 'true'
        run: make bin/spawn-in-init-checker

      - name: Generate baseline
        run: |
          mkdir -p /tmp/baseline
          bin/spawn-in-init-checker --save-baseline /tmp/baseline/spawn-in-init-baseline.txt

      - name: Cache baseline
        uses: actions/cache/save@v4
        with:
          path: /tmp/baseline/spawn-in-init-baseline.txt
          key: spawn-in-init-baseline-${{ github.sha }}

  # On PRs: check against cached main baseline
  check:
    name: Check for spawn in initialize
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    container: 84codes/crystal:latest-ubuntu-24.04
    steps:
      - name: Install dependencies
        run: DEBIAN_FRONTEND=noninteractive apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y liblz4-dev nodejs llvm-dev g++ libgc-dev

      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Shards install
        run: shards install --production

      - name: Cache checker binary
        id: cache-checker
        uses: actions/cache@v4
        with:
          path: bin/spawn-in-init-checker
          key: spawn-in-init-checker-${{ hashFiles('src/spawn_in_init_checker.cr') }}-${{ runner.os }}

      - name: Build checker
        if: steps.cache-checker.outputs.cache-hit != 'true'
        run: make bin/spawn-in-init-checker

      - name: Restore baseline from main
        id: baseline
        uses: actions/cache/restore@v4
        with:
          path: /tmp/baseline/spawn-in-init-baseline.txt
          key: spawn-in-init-baseline-will-not-match
          restore-keys: spawn-in-init-baseline-

      - name: Run checker
        id: check
        run: |
          set +e

          if [ -f /tmp/baseline/spawn-in-init-baseline.txt ]; then
            echo "mode=baseline" >> "$GITHUB_OUTPUT"
            output=$(bin/spawn-in-init-checker --check-baseline /tmp/baseline/spawn-in-init-baseline.txt 2>&1)
            exit_code=$?
          else
            echo "mode=changed-files" >> "$GITHUB_OUTPUT"
            echo "No cached baseline found, checking changed files only."
            BASE="${{ github.event.pull_request.base.sha }}"
            if [ -n "$BASE" ]; then
              git fetch origin "$BASE" --depth=1 2>/dev/null || true
              git diff --name-only "$BASE" "${{ github.sha }}" -- 'src/**' > /tmp/changed-files.txt
            else
              git diff --name-only HEAD~1 -- 'src/**' > /tmp/changed-files.txt
            fi
            echo "Changed files:" && cat /tmp/changed-files.txt
            output=$(bin/spawn-in-init-checker --changed-files /tmp/changed-files.txt 2>&1)
            exit_code=$?
          fi

          echo "$output"
          echo "$output" > /tmp/checker-output.txt

          has_new=$(echo "$output" | grep -q "^NEW" && echo "true" || echo "false")
          has_fixed=$(echo "$output" | grep -q "^FIXED" && echo "true" || echo "false")

          {
            echo "has_new=$has_new"
            echo "has_fixed=$has_fixed"
          } >> "$GITHUB_OUTPUT"

          exit $exit_code

      - name: Comment on PR (new violations)
        if: failure() && steps.check.outputs.has_new == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const output = fs.readFileSync('/tmp/checker-output.txt', 'utf8');
            const mode = '${{ steps.check.outputs.mode }}';

            const lines = output.split('\n');
            let body = '## :x: New spawn-in-initialize violations\n\n';
            body += 'The following `initialize` methods now transitively reach `spawn`. ';
            body += 'This is problematic because the spawned fiber may run before the object is fully constructed.\n\n';
            body += '```\n';
            let inNew = false;
            for (const line of lines) {
              if (line.startsWith('NEW ')) inNew = true;
              else if (line.startsWith('FIXED ') || line.startsWith('Baseline') || line.startsWith('Found')) inNew = false;
              if (inNew) body += line + '\n';
            }
            body += '```\n\n';
            body += '**To fix:** Refactor to two-phase init (constructor + `start` method).\n';
            if (mode === 'changed-files') {
              body += '\n_Note: No baseline from main was available. Only files changed in this PR were checked._\n';
            }

            const marker = '<!-- spawn-in-init-check -->';
            body = marker + '\n' + body;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const existing = comments.find(c => c.body.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

      - name: Comment on PR (violations fixed)
        if: success() && steps.check.outputs.has_fixed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const output = fs.readFileSync('/tmp/checker-output.txt', 'utf8');

            const lines = output.split('\n');
            let fixed = [];
            let inFixed = false;
            for (const line of lines) {
              if (line.startsWith('FIXED ')) inFixed = true;
              else if (line === '' && inFixed) inFixed = false;
              if (inFixed && line.startsWith('  ')) fixed.push(line.trim());
            }

            let body = '## :tada: Spawn-in-initialize violations fixed!\n\n';
            body += 'The following `initialize` methods no longer reach `spawn`:\n\n';
            for (const ref of fixed) {
              body += `- \`${ref}\`\n`;
            }

            const marker = '<!-- spawn-in-init-check -->';
            body = marker + '\n' + body;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const existing = comments.find(c => c.body.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }
